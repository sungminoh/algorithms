#! /usr/bin/env python
# -*- coding: utf-8 -*-
# vim:fenc=utf-8
#
# Copyright Â© 2020 sungminoh <smoh2044@gmail.com>
#
# Distributed under terms of the MIT license.

"""
Given an unsorted array of integers, find the number of longest increasing subsequence.

Example 1:

Input: [1,3,5,4,7]
Output: 2
Explanation: The two longest increasing subsequence are [1, 3, 4, 7] and [1, 3, 5, 7].

Example 2:

Input: [2,2,2,2,2]
Output: 5
Explanation: The length of longest continuous increasing subsequence is 1, and there are 5 subsequences' length is 1, so output 5.

Note:
Length of the given array will be not exceed 2000 and the answer is guaranteed to be fit in 32-bit signed int.
"""
import sys
from typing import List
import pytest


class Solution:
    def findNumberOfLIS(self, nums: List[int]) -> int:
        if not nums:
            return 0
        lencnt = []
        for i in range(len(nums)):
            ml, ct = 1, 1
            for j in range(i):
                if nums[j] >= nums[i]:
                    continue
                l, c = lencnt[j]
                l += 1
                if l > ml:
                    ml = l
                    ct = c
                elif l == ml and ml > 1:
                    ct += c
            lencnt.append((ml, ct))
        ml, ct = lencnt[0]
        for l, c in lencnt[1:]:
            if l > ml:
                ml = l
                ct = c
            elif l == ml:
                ct += c
        return ct

    def __findNumberOfLIS(self, nums: List[int]) -> int:
        if not nums:
            return 0

        sub = []
        for i in range(len(nums)):
            ret = [[nums[i]]]
            for j in range(i):
                seqs = sub[j]
                for seq in seqs:
                    if seq[-1] < nums[i]:
                        seq = seq + [nums[i]]
                        if len(seq) > len(ret[0]):
                            ret = [seq]
                        elif len(seq) == len(ret[0]):
                            ret.append(seq)
            sub.append(ret)

        ret = sub[0]
        for i in range(1, len(nums)):
            seqs = sub[i]
            if len(seqs[0]) > len(ret[0]):
                ret = seqs
            elif len(seqs[0]) == len(ret[0]):
                ret.extend(seqs)

        return len(ret)

    def _findNumberOfLIS(self, nums: List[int]) -> int:
        m = -float('inf')
        cnt = 0
        if not nums:
            return 0

        def lis(i, cur):
            nonlocal cnt, m
            if len(cur) + (len(nums) - i) < m:
                return
            if i == len(nums):
                if len(cur) == m:
                    cnt += 1
                if len(cur) > m:
                    m = len(cur)
                    cnt = 1
                return
            if not cur or nums[i] > cur[-1]:
                cur.append(nums[i])
                lis(i+1, cur)
                cur.pop()
            lis(i+1, cur)

        lis(0, [])
        return cnt


@pytest.mark.parametrize('nums, expected', [
    ([1,3,5,4,7], 2),
    ([2,2,2,2,2], 5),
    ([], 0),
    ([3,1,2], 1),
    ([3,-2,3,1,1,-2,3,3,-3,-2,3,1,0,-3,2,-2,1,1,-3,-3,-3,1,-2,3,-3,-3,-2,-1,3,0,-1,3,2,3,3,0,-3,2,0,3,-3,2,0,2,1,-3,2,1,2,1,-2,-3,3,-3,-2,1,2,-1,-1,2,0,-1,2,0,2,0,0,-2,-2,0,2,2,-1,-3,1,3,1,-1,-3,1,0,-2,-1,2,-1,-1,1,1,1,-2,3,3,-3,2,2,3,0,2,3,3,2,3,-1,2,-1,2,0,1,2,2,3], 163488),
    ([10,2,1,4,9,2,3,8,10,8,3,5,8,5,0,8,8,6,0,6,9,8,4,4,5,4,0,1,10,8,10,3,10,2,8,8,7,4,3,7,2,5,3,7,6,5,6,9,1,1,2,7,7,4,10,8,3,-1,7,5,2,7,0,8,4,6,7,3,4,7,1,8,4,1,3,6,0,5,2,10],18),
    ([47772,78785,46273,30033,69022,-49024,-14106,31893,-79662,15949,-56289,-41595,10954,24834,-64191,-84385,53024,41655,-95488,-62488,82066,-77052,90283,48269,-86851,-37915,-62115,8837,51873,-44513,59107,49104,1549,51379,25491,48519,15049,-23257,38313,62857,-10780,36142,14850,-34638,47641,74066,86264,39521,-68071,65581,-80682,80316,15265,12808,-27,-89753,-85592,-51822,-91743,-19110,-94463,-29338,22753,-81860,86927,-57609,51137,53791,24661,31439,23124,24490,-50184,46287,-36887,-56048,-99189,-3631,-59654,72889,-82227,-57795,17732,8514,71209,22093,42798,16344,-72296,-28959,83629,81546,-36953,71344,56186,91829,-68753,13024,50278,52896,81452,-27968,-37735,50879,68912,97506,-54604,-98090,-76170,-64191,77171,-12635,-12852,52469,18389,17243,-33061,63197,13838,86693,367,49788,-98802,65533,-2888,-87919,71292,17859,37045,-86096,-54779,34416,-5530,77674,-67443,48676,59985,96393,84606,96325,-16410,36096,88100,-47795,62921,71696,37755,-9942,-89403,-55556,38846,68217,97758,97849,23317,72352,-35931,31373,-89012,88949,54710,25538,97596,-34110,94129,3514,35361,18937,-93041,-83156,-71375,-76976,-18819,36631,65557,-37461,-57064,18567,70447,33977,89781,17431,-11077,75892,13637,-12206,-3672,4525,-85936,25683,-43659,-22527,37595,84629,351,70867,6919,-83946,56772,-47428,-14777,71555,-63280,89638,51863,-88705,-76918,26463,-34400,36266,-10441,94502,48609,95372,97713,8758,-50912,-92167,-66819,-53850,-39255,8642,25911,8885,42549,-61347,45833,-25529,54770,87129,63653,-70460,-24794,18870,40010,34549,11376,80355,69872,70550,77550,30580,3910,94946,66056,52781,53132,29986,5797,27324,36539,33021,58595,22812,-94138,-73855,19117,64077,12285,64427,90994,95331,6237,-39471,78814,63665,-80308,89126,41034,-52103,62980,29656,82678,-64012,-73964,84873,63121,28559,27955,31523,32526,-89573,-42127,29493,13497,-6682,92212,-96664,46064,51314,-8181,-78760,29947,-25923,74928,39332,17922,58260,34044,11037,17277,-84723,10184,94182,93436,82379,55599,75643,99231,48781,-78240,97991,75086,49351,135,-5555,79708,11517,46995,-25267,64370,-15800,40267,89282,90270,94130,14506,36756,-32254,21779,-32717,-83486,6959,92827,38765,57353,72066,4291,78151,61983,-52125,-25193,75246,90781,-63116,76393,-75737,-55069,14521,54212,10059,49476,-75559,23274,50786,33985,96573,96012,17545,54154,51611,56489,-85693,-75062,11319,89797,22033,-17100,-7078,-67168,54922,1951,95766,14725,46888,-62179,8814,52876,94291,-63304,52909,-98368,-65577,10901,85187,99147,44361,-40168,81783,68821,88763,3973,49390,-39766,86685,98046,94964,96068,2446,74714,-494,28035,39321,47561,42016,6018,-69606,12055,-62210,-45464,16179,-19422,8700,5130,35053,-64118,76048,94471,-50061,11543,-45998,96000,54894,81336,-333,-51308,84697,73637,17957,47696,68120,69484,15606,39068,-55303,-47370,46300,-99582,-71266,36148,83861,79792,-80882,36573,90111,-14824,-7622,71663,71068,42882,12075,72375,98702,83590,-31309,58991,52409,50187,46858,29601,65040,20365,37410,-82923,-95233,32352,-73148,48840,-46413,25079,-16911,-85445,-11450,-95026,7194,26594,50363,21459,8659,50450,49699,-8508,-21625,40747,-62482,61762,93742,80135,-52587,-62054,-281,33571,98075,54882,97966], 32256),
])
def test(nums, expected):
    assert expected == Solution().findNumberOfLIS(nums)


if __name__ == '__main__':
    sys.exit(pytest.main(["-s", "-v"] + sys.argv))
